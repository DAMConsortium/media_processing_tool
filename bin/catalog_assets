#!/usr/bin/env ruby
# A utility to create a CSV of the file properties.
#
# If process-xml-files is true only the xml files then the file paths inside of supported xml files will be parsed and the files will be
# analyzed and added to the output
#
lib_path = File.expand_path('../../lib', __FILE__)
$:.unshift(lib_path) if !$:.include?(lib_path) and File.exists?(lib_path)

require 'cgi'
require 'csv'
require 'find'
require 'json'
require 'logger'
require 'mig'
require 'open3'
require 'optparse'
require 'shellwords'
require 'time'
require 'uri'

#require 'mig/modules/ffmpeg'

DEFAULT_MEDIA_FILE_PATH_FIELD_NAME = 'Media File Path'

options = { }
options_file_name = nil
op = OptionParser.new
op.on('--path PATH', 'The path to catalog') { |v| options[:path_to_catalog] = v }
op.on('--[no-]recursive', 'Determines if The directory tree will be recursive or not. If not then path can be a glob pattern.') { |v| options[:recursive] = v }
op.on('--destination-path PATH', 'The path and file name of the csv to create.') { |v| options[:destination_path] = v }
op.on('--help', 'Display this message.') { puts op; exit }
op.parse!(ARGV.dup)
op.parse!(ARGV.dup) if op.load(options_file_name)

@logger = Logger.new(STDOUT)
def logger; @logger end

@mig = MediaInformationGatherer.new(options)
def mig; @mig end

path_to_catalog = options[:path_to_catalog]
recursive = options[:recursive]
destination_path = options[:destination_path]
media_file_path_field_name = options[:media_file_path_field_name] || DEFAULT_MEDIA_FILE_PATH_FIELD_NAME

path_to_catalog  ||= '/assets/**/*.mov'
destination_path ||= '/tmp/assets.csv'


def unescape_fcp_file_path_url(file_path_url)
  URI(file_path_url).path.gsub(/(%(?:[2-9]|[A-F])(?:\d|[A-F]))/) { |v| CGI.unescape(v) }
end

def process_media_file_paths(media_file_paths, options = { })
  xml_file_path = options[:xml_file_path]
  xml_file_path_field_name = options[:xml_file_path_field_name] || 'XML File Path'

  media_file_paths = media_file_paths.uniq
  media_file_path_data = { }
  media_file_path_count = media_file_paths.length
  media_file_path_counter = 0
  media_file_paths.each do |mfp|
    media_file_path_counter += 1
    logger.debug { "Processing Media File Path #{media_file_path_counter} of #{media_file_path_count}. '#{mfp}'" }
    #next unless File.exists?(mfp)
    #md = @ffmpeg.run(mfp)
    mds = mig.run(mfp)
    md = mds[:common]
    md[xml_file_path_field_name] = xml_file_path if xml_file_path
    md = md.delete_if { |k, v| %w(output command).include? k }
    #md.merge!(File.stat(mfp).to_hash)
    media_file_path_data[mfp] = md
  end
  media_file_path_data
end

def data_to_table(media_file_paths_with_data)

end

media_file_paths = recursive ? Find.find(path_to_catalog) : Dir.glob(path_to_catalog)

media_file_paths_with_data = process_media_file_paths(media_file_paths)


fields = { media_file_path_field_name => '' }
media_file_paths_with_data.each { |_, data| fields.merge!(data) }
empty_record = Hash[fields.map { |k,_| [k, ''] }]

CSV.open(destination_path, 'w') do |csv|
  csv << fields.keys
  media_file_paths_with_data.each do |media_file_path, data|
    data[media_file_path_field_name] = media_file_path
    csv << empty_record.merge(data).values
  end
end
puts "Output written to: #{destination_path}"